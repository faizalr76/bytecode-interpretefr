<html>
  <body>
    <table border=1 width=100% height=100%>
      <tr>
        <td align=center>
          Code
          <input type="button" value="Compile"  onclick="compile()" ></input>
        </td>
        <td align=center>
          Bytecode
          <input type="button" value="Run"  onclick="run_bytecode()" ></input>
          <br>
          <input type="button" value="Load" onclick="load_bytecode()"></input>
          <input type="button" value="Step" onclick="step_bytecode()"></input>
        </td>
        <td align=center>
          Stack
        </td>
      </tr>

      <tr height=100%>
        <td>
          <textarea id="lisp_ui" rows=50 cols=80>
(if (> 3 2) "true" "false")
          </textarea>
        </td>
        <td>
          ip: <input id="ip_text"></input><br>
          <textarea id="bytecode_area" rows=50 cols=80>
push 2
push 3
add 2
print
jmp -9
          </textarea>
        </td>
        <td>
          sp: <input id="sp_text"></input><br>
          <textarea id="stack_area" rows=50 cols=80>
          </textarea>
        </td>
      </tr>
    </table>

    <script>
      // add sub mul div lt eq jmp jmpt jmpf push load gload store gstore print pop halt
      // loadd
      //   offset = code[ip++];
      //   stack[++sp] = stack[fp+offset];

      var g = window;
      var bytecode_area = document.getElementById("bytecode_area");
      var stack_area = document.getElementById("stack_area");
      var ip_text = document.getElementById("ip_text");
      var sp_text = document.getElementById("sp_text");
      var sym_cache = new Map();


      // code functions //

      var code;
      var ip = 0;

      var code_ui = document.getElementById("bytecode_area");
      let ip_ui = document.getElementById("ip_text");

      function code_next () {
        let ret = code[ip];
        ip += 1;
        return ret;
      }

      function code_jmp (offset) {
        ip += offset;
      }

      // stack funtions //

      var stack = Array(100);
      var sp = -1;

      var stack_ui = document.getElementById("stack_area");
      var sp_ui = document.getElementById("sp_text");

      function stack_push (x) {
        sp += 1;
        stack[sp] = x;
        // update ui
      }

      function stack_pop (n) {
        if (n) {
          let beg = sp - n + 1;
          sp -= n;
          let ret = stack.slice(beg, n);
          console.log("stack_pop: " + ret);
          return ret;
        }
        else {
          let ret = stack[sp];
          sp -= 1;
          // update ui
          return ret;
        }
      }

      // end stack functions //

      update_ui();

      function Sym (name) {
        return {
          toString: function () {
            return name;
          }
        };
      }

      function sym(s) {
        if (!sym_cache.has(s))
          sym_cache.set(s, Sym(s));
        return sym_cache.get(s);
      }

      function atom (x) {
        if (x[0] === '"')
          return x.substring(1, x.length-1);
        else if (!isNaN(x))
          return Number(x);
        else
          return sym(x);
      }

      // Create syms for comparison in parse and interpret.

      for (let name of ["quote", "do", "if", "push", "print", "jmp", "jmpt", "jmpf", "add", "sub", 
        "gt", "lt"] ) {
        g[name + "_"] = sym(name);
      }

      function lex (s) {
        return s.match(/,@|[()'`,]|"[^"]*"|[^ \t\n()]+/g);
      }

      function is_num (x) {
        return !isNaN(x);
      }

      function parse (tokens) {
        let ret = [do_];
        while (tokens.length) {
          ret.push(parse1(tokens));
        }

        if (ret.length === 2) {
          return ret[1];
        }
        else {
          return ret;
        }
      }

      String.prototype.toString = function () {
        return '"' + this + '"';
      }

      function parse1 (tokens) {
        let tok = tokens.shift();
        if (tok === '(') {
          let ret = [];
          while (true) {
            if (tokens.length === 0) {
              throw("Expected clsoing-paren not EOF !");
            }
            else if (tokens[0] === ')') {
              tokens.shift();
              return ret;
            }
            else {
              ret.push(parse1(tokens));
            }  
          }   // end-while
        }    
        else if (tok === ')') {
          throw("Unexpected closing-paren !");
        }
        else if (tok === "'") {
          let ret = [quote_, parse1(tokens)];
          return ret;
        }
        else if (is_num(tok)) {
          return Number(tok);
        }
        else if (tok[0] === '"') {
          let ret = tok.substring(1, tok.length - 1);
          return new String(ret);
        }
        else { 
          return sym(tok); 
        }
      }  // end-fun

      function read (s) {
        let arr = lex(s);
        bytecodes = arr.map(function (elem) {
          return atom(elem);
        });
        console.log("read(): " + bytecodes);
        return bytecodes;
      } // end parse1

      // compile //

      env = new Map();
      env.set(sym("+"), add_);
      env.set(sym("-"), sub_);
      env.set(sym(">"), gt_);
      env.set(sym("<"), lt_);

      function kompile (x) {
        if (Array.isArray(x)) {
          //if (x[0] === sym("+")) {
          if (env.has(x[0])) {
            for (let i = 1; i < x.length; i++) {
              kompile(x[i]);
            }
            code.push(env.get(x[0]));
            code.push(x.length - 1);
          }
          else if (x[0] === if_) {
            kompile(x[1]);
            code.push(jmpf_);
            code.push("??");
            let ip1 = code.length - 1;
            kompile(x[2]);
            code.push(jmp_, "??");
            let ip2 = code.length - 1;
            code[ip1] = ip2 - ip1;
            kompile(x[3]);
            let ip3 = code.length - 1;
            code[ip2] = ip3 - ip2;
          }
          else if (x[0] === do_) {
            for (let i = 1; i < x.length; i++) {
              kompile(x[i]);
            }
          }
        }
        else {
          code.push(push_);
          code.push(x);
        }
      }

      function compile () {
        console.log("compiling..");
        let s = lisp_ui.value;

        Array.prototype.toString = function () { return this.join(","); };
        let tokens = lex(s);
        console.log("tokens: " + tokens);

        Array.prototype.toString = function () { return "(" + this.join(" ") + ")"; };
        let ast = parse(tokens);
        console.log("ast: " + ast);

        code = [];
        kompile(ast);
        console.log("code: " + code);
        code_ui.value = code.join("\n");

      }

      let add_op = (a, b) => a + b;
      let sub_op = (a, b) => a - b;
      let mul_op = (a, b) => a * b;
      let div_op = (a, b) => a / b;
      let gt_op  = (a, b) => a > b;
      let lt_op  = (a, b) => a < b;

      function interpret () {
        let bytecode = code_next();
        if (bytecode === g.push_) {
          stack_push(code_next());
        }
        else if (bytecode === g.print_) {
          alert(stack_pop());
        }
        else if (bytecode === g.jmp_) {
          let offset = code_next();
          code_jmp(offset);
        }
        else if (bytecode === g.jmpf_) {
          let offset = code_next();
          if (stack_pop() === false) {
            console.log("ip: " + ip + ", offset: " + offset);
            code_jmp(offset);
          }
        }
        else if (bytecode === g.add_) {
          let argc = code_next();   
          let ret = stack_pop(argc).reduce(add_op);
          stack_push(ret);
        }
        else if (bytecode === g.sub_) {
          let argc = code_next();   
          let ret = stack_pop(argc).reduce(sub_op);
          stack_push(ret);
        }
        else if (bytecode === g.gt_) {
          let argc = code_next();   
          let ret = stack_pop(argc).reduce(gt_op);
          stack_push(ret);
        }
        else {
          alert(`I don't know how to: ${bytecode}`);
        }
      }

      function update_ui () {
        ip_ui.value = ip;
        sp_ui.value = sp;
        stack_ui.value = stack.slice(0, sp + 1).join("\n");
      }

      function run_bytecode () {
        g.ip = 0;
        g.sp = -1;
        g.code = read(g.bytecode_area.value);
        for (let i = 0; i < g.code.length; i++) {
          interpret(g.code[g.ip++]);
        }
        update_ui();
      }

      function load_bytecode () {
        g.code = read(g.bytecode_area.value);
        ip = 0;
        sp = -1;
      }

      function step_bytecode () {
        //g.code = (g.ip === 0) ? read(g.bytecode_area.value) : g.code;
        //g.ip = +g.ip_text.value;

        if (g.ip < g.code.length) {
          interpret();
          update_ui();
        }
        else {
          alert("No more code !");
        }
      }
    </script>
  </body>
</html>
